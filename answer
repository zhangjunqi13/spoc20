一个比较具体的例子，说明银行家算法判断出不安全的状态下不会出现死锁:

某个进程申请的资源超过最大需求量时，银行家算法会判定为不安全状态，但此时没有出现死锁。
当前可用资源不能满足请求，银行家算法会判定为不安全状态，但是有可能某些进程会在运行结束之前，提前释放一些资源，使得可用资源可以满足请求，这时就不会出现死锁。
这里的问题在于，银行家算法只考虑了当前时刻下状态是否安全，而且只考虑了资源申请的上界，但并没有考虑到未来资源的分配情况。
